---
layout: post
title:  "java hash处理方法"
date:   2017-8-4
categories: Java
tag: hash处理方法
---


* content
{:toc}


## hash处理冲突的方法

通过构造良好的的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希另一个关键问题，创建哈希表和查找哈希表都会遇到冲突，两种情况下冲突的解决方法应该是一致的，下面以创建哈希表为例说明解决冲突的常用方法
### 开方定址法

这种方法也称在散列法，基本思想是：但关键字key的哈希地址p=Ｈ(key)出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2....，直到找出一个不冲突的哈希地址pi,蒋相应元素存入其中，这种方法 有一个通用的再散列函数形式：Hi=(Hi(key)+di)%m i=1,2,..,n 其中H(key)为哈希函数，m为表长，di称为增量序列，增量序列的取值方式不同，相应的再散列方式野不同，主要有三种:

线性探测再散列

di=1,2,3,...,m-1

特点：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表

二次探测再散列

di=1^2,-1^2,2^2,-2^2,...,k^2,-k^2 (k<=m/2)

特点：冲突发生时，在表的左右进行跳跃式探测，比较灵活．

伪随机探测再散列

di=伪随机数序列

具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。 例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元，(表一)。如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元，(表二)。如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元，（表三）。

表1

![1](/styles/images/mdImg/0-0.png)

表2
![0-01](/styles/images/mdImg/0-1.png)

表3
![0-01](/styles/images/mdImg/0-2.png)

### 再哈希法

这种方法是同时构造多个不同的哈希函数： Hi=RH1（key） i=1，2，…，k 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

### 链地址法

这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。 例如，已知一组关键字（32，40，36，53，16，46，71，27，42，24，49，64），哈希表长度为13，哈希函数为：H（key）= key % 13，
